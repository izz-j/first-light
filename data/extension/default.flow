;; -*- mode: common-lisp -*-

(define-call-flow :default (:enabled t)
  (flow initialize-phase
        (flow-state ENTRY/INITIALIZE-PHASE :reset ()
                    (selector nil)
                    (action nil)
                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       PENDING-TASKS)))

        ;; High level description of this flow:
        ;;
        ;; 0. If pre-init is empty, go to 7.
        ;; 1. straight up move components from pre-init to init.
        ;; 2. straight up move actors from pre-init to init.
        ;; 3. run initalize-component by-type in init.
        ;; 4. realize-components from init to active.
        ;; 5. realize-actors from init to active.
        ;; 6. realize-phase-commit (new name: WHILE-INITIALIZE-PHASE)
        ;;    make a decision:
        ;;    If still stuff in pre-init go to 1
        ;;    If nothing in pre-init, go to 7.
        ;; 7. exit flow

        ;; 0
        (flow-state PENDING-TASKS :reset ()
                    (selector nil)
                    (action nil)
                    (transition
                     (lambda (core-state)
                       (if (pending-preinit-tasks-p core-state)
                           INIT-COMPONENTS
                           EXIT/INITIALIZE-PHASE))))

        ;; 1
        (flow-state INIT-COMPONENTS :reset ()
                    (selector
                     (lambda (core-state)
                       (values
                        :type-policy
                        (component-preinitialize-by-type-view core-state))))

                    (action
                     (lambda (core-state component)
                       (component/preinit->init core-state component)))

                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       INIT-ACTORS)))
        ;; 2
        (flow-state INIT-ACTORS :reset ()
                    (selector
                     (lambda (core-state)
                       (values
                        :identity-policy
                        (actor-preinitialize-db core-state))))

                    (action
                     (lambda (core-state component)
                       (actor/preinit->init core-state component)))

                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       PROTOCOL-INITIALIZE-COMPONENTS)))

        ;; 3
        (flow-state PROTOCOL-INITIALIZE-COMPONENTS :reset ()
                    (selector
                     (lambda (core-state)
                       (values :type-policy
                               (component-initialize-by-type-view core-state))))

                    (action
                     (lambda (core-state component)
                       ;; NOTE: If any new actors/components are generated
                       ;; here. They end up in pre-init state.
                       (initialize-component component (context core-state))))

                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       REALIZE-COMPONENTS)))
        ;; 4
        (flow-state REALIZE-COMPONENTS :reset ()
                    (selector
                     (lambda (core-state)
                       (values :type-policy
                               (component-initialize-by-type-view core-state))))

                    (action
                     (lambda (core-state component)
                       (component/init->active core-state component)))

                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       REALIZE-ACTORS)))

        ;; 5
        (flow-state REALIZE-ACTORS :reset ()
                    (selector
                     (lambda (core-state)
                       (values :identity-policy
                               (actor-initialize-db core-state))))

                    (action
                     (lambda (core-state inst)
                       (actor/init->active core-state inst)))

                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       WHILE-INITIALIZE-PHASE)))

        ;; 6
        (flow-state WHILE-INITIALIZE-PHASE :reset ()
                    (selector NIL)
                    (action NIL)

                    (transition
                     (lambda (core-state)
                       ;; Running PROTOCOL-INITIALIZE-COMPONENTS may have
                       ;; cause additional actors/components to be created, so
                       ;; we check for that here and repeat as needed.
                       (if (pending-preinit-tasks-p core-state)
                           ;; Then do the process over again.
                           INIT-COMPONENTS
                           ;; Or exit this phase, we're done initializing.
                           EXIT/INITIALIZE-PHASE))))

        ;; 7
        (flow-state EXIT/INITIALIZE-PHASE :reset ()
                    (selector NIL)
                    (action NIL)
                    (transition NIL)))

  (flow active-phase
        (flow-state ENTRY/ACTIVE-PHASE :reset ()
                    (selector NIL)

                    (action
                     (lambda (core-state unused)
                       (declare (ignore unused))
                       ;; TODO: right spot for this? Maybe in render
                       ;; flow-state.
                       (setf (shaders (context core-state))
                             (compiled-shaders (shaders core-state)))))

                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       PHYSICS-LOOP)))

        (flow-state PHYSICS-LOOP :reset ()
                    (selector
                     (lambda (core-state)
                       (values :identity-policy
                               core-state)))

                    (action
                     (lambda (core-state inst)
                       (declare (ignore inst))
                       (let ((display (display core-state)))
                         (box.fm:tick
                          display
                          (hz display)
                          (lambda ()
                            ;; Run the user's physics-update protocol
                            (execute-flow core-state
                                          :default
                                          'active-phase
                                          'PROTOCOL-PHYSICS-UPDATE
                                          :come-from-state-name
                                          :EF-PHYSICS-UPDATE)

                            ;; Then update ALL transforms to current
                            ;; local/model
                            (fl.comp.transform:map-nodes
                             #'fl.comp.transform::transform-node
                             (actor-component-by-type
                              (scene-tree core-state)
                              'fl.comp.transform:transform))

                            ;; Then, determine if any physics collisions
                            ;; happened and do whatever needs to be done.
                            (execute-flow core-state
                                          :default
                                          'active-phase
                                          'PHYSICS-COLLISIONS
                                          :come-from-state-name
                                          :EF-PHYSICS-COLLISIONS)))

                         ;; Then produce the interpolated model. Note that
                         ;; physics collisions used ONLY the physics
                         ;; computations to do their collisions instead of
                         ;; the interpolated models.
                         (fl.comp.transform::interpolate-transforms
                          (actor-component-by-type (scene-tree core-state)
                                                   'fl.comp.transform:transform)
                          (box.fm:alpha display)))))

                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       MAKE-ACTIVE-CAMERA-VIEW)))

        (flow-state PROTOCOL-PHYSICS-UPDATE :reset ()
                    (selector
                     (lambda (core-state)
                       (values :type-policy
                               (component-active-by-type-view core-state))))

                    (action
                     (lambda (core-state inst)
                       (physics-update-component inst (context core-state))))

                    (transition NIL))

        ;; TODO: PHYSICS-COLLISIONS is not yet implemented, there may be
        ;; more work here than this single state. This will compute
        ;; collisions and then inform the recipients of those
        ;; collisions as desired in the boundary regions components
        ;; (yet to be written).
        (flow-state PHYSICS-COLLISIONS :reset ()
                    (selector NIL)

                    (action
                     (lambda (core-state inst)
                       (declare (ignore core-state inst))))

                    (transition NIL))

        ;; TODO: Should I run flow destroy-phase just before this next
        ;; flow-state so that those actors/components aren't even drawn?
        ;; Currently, I defer all actor/component destruction until the end of
        ;; frame, far after this. I don't know what is better yet.

        (flow-state MAKE-ACTIVE-CAMERA-VIEW :reset ()
                    (selector
                     (lambda (core-state)
                       (symbol-macrolet ((camera (active-camera
                                                  (context core-state))))
                         (unless (and camera (fl.comp.camera::activep camera))
                           (let ((new-camera (fl.comp.camera::find-active-camera
                                              core-state)))
                             (setf camera new-camera)))
                         (values :identity-policy
                                 camera))))

                    (action
                     (lambda (core-state camera)
                       (when (and camera (fl.comp.camera::activep camera))
                         (fl.comp.camera:compute-camera-view
                          camera
                          (context core-state)))))

                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       PROTOCOL-UPDATE-COMPONENT)))

        (flow-state PROTOCOL-UPDATE-COMPONENT :reset ()
                    (selector
                     (lambda (core-state)
                       (values :type-policy
                               (component-active-by-type-view core-state))))

                    (action
                     (lambda (core-state inst)
                       (update-component inst (context core-state))))

                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       PROTOCOL-RENDER-COMPONENT)))


        (flow-state PROTOCOL-RENDER-COMPONENT :reset ()
                    (selector
                     (lambda (core-state)
                       (values :type-policy
                               (component-active-by-type-view core-state))))

                    (action
                     (lambda (core-state inst)
                       (render-component inst (context core-state))))

                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       EXIT/ACTIVE-PHASE)))

        (flow-state EXIT/ACTIVE-PHASE :reset ()
                    (selector NIL)
                    (action NIL)
                    (transition NIL)))

  (flow destroy-phase
        (flow-state ENTRY/DESTROY-PHASE :reset ()
                    (selector NIL)
                    (action NIL)
                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       PENDING-PREDESTROY-TASKS)))

        ;; TODO: Fix me.

        ;; This should handle if I spawn an actor/component and then destroy it
        ;; in the same function, etc, etc.
        ;;
        ;; 0. If pre-destroy (actor and components) is empty, go to 5
        ;;
        ;; 1. move components (<= ttl 0) in pre-destroy from init/active to
        ;;    destroy.
        ;;
        ;; 2. move root actors (<= ttl 0) (and their components)
        ;;    in pre-destroy from init/active to destroy.
        ;;
        ;; 3. Recursively move all actor children found in destroy from
        ;;    init/active into destroy, Set any actor/component ttl in any
        ;;    discovered instances to 0, since the root with ttl <= 0 overrides
        ;;    all pending ttls for anything that may be in the process of being
        ;;    destroyed.
        ;;
        ;; 4. A) decrement ttl by frame-time for predestroying components
        ;;    B) decrement ttl by frame-time for predestroying actors.
        ;;
        ;; 5. If destroy is empty, go to 11.
        ;;
        ;; 6. run DESTROY-COMPONENT by-type in destroy.
        ;;
        ;; 7. disconnect all destroyed actors from the scene heirarchy.
        ;;
        ;; 8. release-components (and remove from actors) from destroy.
        ;;
        ;; 9. release-actors (which now should be empty) from destroy.
        ;;
        ;; 10. restart to see if anything else got marked to be destroyed
        ;;     during this entire process, goto 0.
        ;;
        ;; 11. exit flow.

        ;; 0
        (flow-state PENDING-PREDESTROY-TASKS :reset ()
                    (selector NIL)

                    (action NIL)

                    (transition
                     (lambda (core-state)
                       ;; Start of a while construct
                       (if (pending-predestroy-tasks-p core-state)
                           PREPARE-PREDESTROY-COMPONENTS
                           PENDING-DESTROY-TASKS))))

        ;; 1
        (flow-state PREPARE-PREDESTROY-COMPONENTS :reset ()
                    (selector
                     (lambda (core-state)
                       (values :identity-policy
                               (component-predestroy-view core-state))))

                    (action
                     (lambda (core-state component)
                       (when (<= (ttl component) 0)
                         (component/init-or-active->destroy core-state
                                                            component))))

                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       PREPARE-PREDESTROY-ACTORS)))

        ;; 2
        (flow-state PREPARE-PREDESTROY-ACTORS :reset ()
                    (selector
                     (lambda (core-state)
                       (values :identity-policy
                               (actor-predestroy-view core-state))))

                    (action
                     (lambda (core-state actor)
                       (when (<= (ttl actor) 0)
                         (actor/init-or-active->destroy core-state actor))))

                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       DESTROY-ACTOR-CHILDREN)))

        ;; 3
        (flow-state DESTROY-ACTOR-CHILDREN :reset ()
                    (selector
                     (lambda (core-state)
                       (values :identity-policy
                               ;; NOTE: We get the keys here because the action
                               ;; will be adding values to this hash table as we
                               ;; iterate over the keys. We need to copy the
                               ;; list of keys in order to satisfy the traversal
                               ;; rules of hash tables.
                               (alexandria:hash-table-keys
                                (actor-destroy-db core-state)))))

                    (action
                     (lambda (core-state actor)
                       ;; NOTE: See selector for this flow-state.
                       ;;
                       ;; NOTE: We check for the actor here since we could have
                       ;; had an empty list returned in the selector. That will
                       ;; call this function with actor bound to nil.
                       (when actor
                         (actor/destroy-descendants core-state actor))))

                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       DECREMENT-COMPONENT-DESTROY-TIMER)))
        ;; 4 A
        (flow-state DECREMENT-COMPONENT-DESTROY-TIMER :reset ()
                    (selector
                     (lambda (core-state)
                       (values :identity-policy
                               (component-predestroy-view core-state))))

                    (action
                     (lambda (core-state component)
                       (component/countdown-to-destruction core-state
                                                           component)))

                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       DECREMENT-ACTOR-DESTROY-TIMER)))

        ;; 4 B
        (flow-state DECREMENT-ACTOR-DESTROY-TIMER :reset ()
                    (selector
                     (lambda (core-state)
                       (values :identity-policy
                               (actor-predestroy-view core-state))))
                    (action
                     (lambda (core-state actor)
                       (actor/countdown-to-destruction core-state actor)))

                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       PENDING-DESTROY-TASKS)))

        ;; 5
        (flow-state PENDING-DESTROY-TASKS :reset ()
                    (selector NIL)
                    (action NIL)
                    (transition
                     (lambda (core-state)
                       (if (pending-destroy-tasks-p core-state)
                           PROTOCOL-DESTROY-COMPONENT
                           EXIT/DESTROY-PHASE))))

        ;; 6
        (flow-state PROTOCOL-DESTROY-COMPONENT :reset ()
                    (selector
                     (lambda (core-state)
                       (values :type-policy
                               (component-destroy-by-type-view core-state))))

                    (action
                     (lambda (core-state component)
                       (destroy-component component (context core-state))))

                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       DISCONNECT-DESTROYED-ACTORS)))

        ;; 7
        (flow-state DISCONNECT-DESTROYED-ACTORS :reset ()
                    (selector
                     (lambda (core-state)
                       (values :identity-policy
                               (actor-destroy-db core-state))))

                    (action
                     (lambda (core-state actor)
                       (actor/disconnect core-state actor)))

                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       RELEASE-COMPONENTS)))

        ;; 8
        (flow-state RELEASE-COMPONENTS :reset ()
                    (selector
                     (lambda (core-state)
                       (values :type-policy
                               (component-destroy-by-type-view core-state))))
                    (action
                     (lambda (core-state component)
                       (component/destroy->released core-state component)))

                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       RELEASE-ACTORS)))

        ;; 9
        (flow-state RELEASE-ACTORS :reset ()
                    (selector
                     (lambda (core-state)
                       (values :identity-policy
                               (actor-destroy-db core-state))))

                    (action
                     (lambda (core-state actor)
                       (actor/destroy->released core-state actor)))

                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       RESTART-PREDESTROY-PHASE)))

        ;; 10
        (flow-state RESTART-PREDESTROY-PHASE :reset ()
                    (selector NIL)
                    (action NIL)
                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       ;; The end of a while construct...
                       PENDING-PREDESTROY-TASKS)))

        ;; 11
        (flow-state EXIT/DESTROY-PHASE :reset ()
                    (selector NIL)
                    (action NIL)
                    (transition NIL)))


  (flow maintenance-phase
        (flow-state ENTRY/MAINTENANCE-PHASE :reset ()
                    (selector NIL)
                    (action NIL)
                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       SHADER-REFRESH)))

        (flow-state SHADER-REFRESH :reset ()
                    (selector
                     (lambda (core-state)
                       (values :identity-policy
                               core-state)))

                    (action
                     (lambda (core-state inst)
                       (declare (ignore inst))
                       (maybe-recompile-shaders core-state)
                       nil))

                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       EXIT/MAINTENANCE-PHASE)))

        (flow-state EXIT/MAINTENANCE-PHASE :reset ()
                    (selector NIL)
                    (action NIL)
                    (transition NIL)))


  (flow perform-one-frame
        (flow-state ENTRY/PERFORM-ONE-FRAME :reset ()
                    (selector NIL)
                    (action NIL)
                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       INITIALIZE-PHASE)))

        (flow-state INITIALIZE-PHASE :reset ()
                    (selector
                     (lambda (core-state)
                       (values :identity-policy
                               core-state)))

                    (action
                     (lambda (core-state inst)
                       (declare (ignore inst))
                       (execute-flow core-state
                                     :default
                                     'initialize-phase
                                     'ENTRY/INITIALIZE-PHASE
                                     :come-from-state-name
                                     :EF-REALIZE-PHASE)))

                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       ACTIVE-PHASE)))

        (flow-state ACTIVE-PHASE :reset ()
                    (selector
                     (lambda (core-state)
                       (values :identity-policy
                               core-state)))

                    (action
                     (lambda (core-state inst)
                       (declare (ignore inst))
                       (execute-flow core-state
                                     :default
                                     'active-phase
                                     'ENTRY/ACTIVE-PHASE
                                     :come-from-state-name
                                     :EF-ACTIVE-PHASE)))

                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       DESTROY-PHASE)))

        (flow-state DESTROY-PHASE :reset ()
                    (selector
                     (lambda (core-state)
                       (values :identity-policy
                               core-state)))

                    (action
                     (lambda (core-state inst)
                       (declare (ignore inst))
                       (execute-flow core-state
                                     :default
                                     'destroy-phase
                                     'ENTRY/DESTROY-PHASE
                                     :come-from-state-name
                                     :EF-DESTROY-PHASE)))

                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       MAINTENANCE-PHASE)))

        (flow-state MAINTENANCE-PHASE :reset ()
                    (selector
                     (lambda (core-state)
                       (values :identity-policy
                               core-state)))

                    (action
                     (lambda (core-state inst)
                       (declare (ignore inst))
                       (execute-flow core-state
                                     :default
                                     'maintenance-phase
                                     'ENTRY/MAINTENANCE-PHASE
                                     :come-from-state-name
                                     :EF-MAINTENANCE-PHASE)))

                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       EXIT/DO-NEXT-FRAME)))

        (flow-state EXIT/DO-NEXT-FRAME :reset ()
                    (selector NIL)
                    (action NIL)
                    (transition NIL))

        (flow-state EXIT/GAME-OVER :reset ()
                    (selector NIL)
                    (action NIL)
                    (transition NIL))))
