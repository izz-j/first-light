;; -*- mode: common-lisp -*-

(define-call-flow :default (:enabled t)
  (flow initialize-phase
        (flow-state ENTRY/INITIALIZE-PHASE :reset ()
                    (selector nil)
                    (action nil)
                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       PENDING-TASKS)))

        ;; High level description of this flow:
        ;;
        ;; 0. If pre-init is empty, go to 7.
        ;; 1. straight up move components from pre-init to init.
        ;; 2. straight up move actors from pre-init to init.
        ;; 3. run initalize-component by-type in init.
        ;; 4. realize-components from init to active.
        ;; 5. realize-actors from init to active.
        ;; 6. realize-phase-commit (new name: WHILE-INITIALIZE-PHASE)
        ;;    make a decision:
        ;;    If still stuff in pre-init go to 1
        ;;    If nothing in pre-init, go to 7.
        ;; 7. exit flow

        ;; 0
        (flow-state PENDING-TASKS :reset ()
                    (selector nil)
                    (action nil)
                    (transition
                     (lambda (core-state)
                       (if (pending-preinit-tasks-p core-state)
                           INIT-COMPONENTS
                           EXIT/INITIALIZE-PHASE))))

        ;; 1
        (flow-state INIT-COMPONENTS :reset ()
                    (selector
                     (lambda (core-state)
                       (values
                        :type-policy
                        (component-preinitialize-by-type-view core-state))))

                    (action
                     (lambda (core-state component)
                       (component/preinit->init core-state component)))

                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       INIT-ACTORS)))
        ;; 2
        (flow-state INIT-ACTORS :reset ()
                    (selector
                     (lambda (core-state)
                       (values
                        :identity-policy
                        (actor-preinitialize-db core-state))))

                    (action
                     (lambda (core-state component)
                       (actor/preinit->init core-state component)))

                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       PROTOCOL-INITIALIZE-COMPONENTS)))

        ;; 3
        (flow-state PROTOCOL-INITIALIZE-COMPONENTS :reset ()
                    (selector
                     (lambda (core-state)
                       (values :type-policy
                               (component-initialize-by-type-view core-state))))

                    (action
                     (lambda (core-state component)
                       ;; NOTE: If any new actors/components are generated
                       ;; here. They end up in pre-init state.
                       (initialize-component component (context core-state))))

                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       REALIZE-COMPONENTS)))
        ;; 4
        (flow-state REALIZE-COMPONENTS :reset ()
                    (selector
                     (lambda (core-state)
                       (values :type-policy
                               (component-initialize-by-type-view core-state))))

                    (action
                     (lambda (core-state component)
                       (component/init->active core-state component)))

                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       REALIZE-ACTORS)))

        ;; 5
        (flow-state REALIZE-ACTORS :reset ()
                    (selector
                     (lambda (core-state)
                       (values :identity-policy
                               (actor-initialize-db core-state))))

                    (action
                     (lambda (core-state inst)
                       (actor/init->active core-state inst)))

                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       WHILE-INITIALIZE-PHASE)))

        ;; 6
        (flow-state WHILE-INITIALIZE-PHASE :reset ()
                    (selector NIL)
                    (action NIL)

                    (transition
                     (lambda (core-state)
                       ;; Running PROTOCOL-INITIALIZE-COMPONENTS may have
                       ;; cause additional actors/components to be created, so
                       ;; we check for that here and repeat as needed.
                       (if (pending-preinit-tasks-p core-state)
                           ;; Then do the process over again.
                           INIT-COMPONENTS
                           ;; Or exit this phase, we're done initializing.
                           EXIT/INITIALIZE-PHASE))))

        ;; 7
        (flow-state EXIT/INITIALIZE-PHASE :reset ()
                    (selector NIL)
                    (action NIL)
                    (transition NIL)))

  (flow active-phase
        (flow-state ENTRY/ACTIVE-PHASE :reset ()
                    (selector NIL)

                    (action
                     (lambda (core-state unused)
                       (declare (ignore unused))
                       ;; TODO: right spot for this? Maybe in render
                       ;; flow-state.
                       (setf (shaders (context core-state))
                             (compiled-shaders (shaders core-state)))))

                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       PHYSICS-LOOP)))

        (flow-state PHYSICS-LOOP :reset ()
                    (selector
                     (lambda (core-state)
                       (values :identity-policy
                               core-state)))

                    (action
                     (lambda (core-state inst)
                       (declare (ignore inst))
                       (let ((display (display core-state)))
                         (box.fm:tick
                          display
                          (hz display)
                          (lambda ()
                            ;; Run the user's physics-update protocol
                            (execute-flow core-state
                                          :default
                                          'active-phase
                                          'PROTOCOL-PHYSICS-UPDATE
                                          :come-from-state-name
                                          :EF-PHYSICS-UPDATE)

                            ;; Then update ALL transforms to current
                            ;; local/model
                            (fl.comp.transform:map-nodes
                             #'fl.comp.transform::transform-node
                             (actor-component-by-type
                              (scene-tree core-state)
                              'fl.comp.transform:transform))

                            ;; Then, determine if any physics collisions
                            ;; happened and do whatever needs to be done.
                            (execute-flow core-state
                                          :default
                                          'active-phase
                                          'PHYSICS-COLLISIONS
                                          :come-from-state-name
                                          :EF-PHYSICS-COLLISIONS)))

                         ;; Then produce the interpolated model. Note that
                         ;; physics collisions used ONLY the physics
                         ;; computations to do their collisions instead of
                         ;; the interpolated models.
                         (fl.comp.transform::interpolate-transforms
                          (actor-component-by-type (scene-tree core-state)
                                                   'fl.comp.transform:transform)
                          (box.fm:alpha display)))))

                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       MAKE-ACTIVE-CAMERA-VIEW)))

        (flow-state PROTOCOL-PHYSICS-UPDATE :reset ()
                    (selector
                     (lambda (core-state)
                       (values :type-policy
                               (component-active-by-type-view core-state))))

                    (action
                     (lambda (core-state inst)
                       (physics-update-component inst (context core-state))))

                    (transition NIL))

        ;; TODO: PHYSICS-COLLISIONS is not yet implemented, there may be
        ;; more work here than this single state. This will compute
        ;; collisions and then inform the recipients of those
        ;; collisions as desired in the boundary regions components
        ;; (yet to be written).
        (flow-state PHYSICS-COLLISIONS :reset ()
                    (selector NIL)

                    (action
                     (lambda (core-state inst)
                       (declare (ignore core-state inst))))

                    (transition NIL))

        ;; TODO: Should I run flow destroy-phase just before this next
        ;; flow-state so that those actors/components aren't even drawn?
        ;; Currently, I defer all actor/component destruction until the end of
        ;; frame, far after this. I don't know what is better yet.

        (flow-state MAKE-ACTIVE-CAMERA-VIEW :reset ()
                    (selector
                     (lambda (core-state)
                       (symbol-macrolet ((camera (active-camera
                                                  (context core-state))))
                         (unless (and camera (fl.comp.camera::activep camera))
                           (let ((new-camera (fl.comp.camera::find-active-camera
                                              core-state)))
                             (setf camera new-camera)))
                         (values :identity-policy
                                 camera))))

                    (action
                     (lambda (core-state camera)
                       (when (and camera (fl.comp.camera::activep camera))
                         (fl.comp.camera:compute-camera-view
                          camera
                          (context core-state)))))

                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       PROTOCOL-UPDATE-COMPONENT)))

        (flow-state PROTOCOL-UPDATE-COMPONENT :reset ()
                    (selector
                     (lambda (core-state)
                       (values :type-policy
                               (component-active-by-type-view core-state))))

                    (action
                     (lambda (core-state inst)
                       (update-component inst (context core-state))))

                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       PROTOCOL-RENDER-COMPONENT)))


        (flow-state PROTOCOL-RENDER-COMPONENT :reset ()
                    (selector
                     (lambda (core-state)
                       (values :type-policy
                               (component-active-by-type-view core-state))))

                    (action
                     (lambda (core-state inst)
                       (render-component inst (context core-state))))

                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       EXIT/ACTIVE-PHASE)))

        (flow-state EXIT/ACTIVE-PHASE :reset ()
                    (selector NIL)
                    (action NIL)
                    (transition NIL)))

  (flow destroy-phase
        (flow-state ENTRY/DESTROY-PHASE :reset ()
                    (selector NIL)
                    (action NIL)
                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       EXIT/DESTROY-PHASE)))

        ;; TODO: Technically, if I spawn-actor then destroy-actor in the same
        ;; function, it might do something funny....

        ;; 0. If pre-destroy (actor and components) is empty, go to 10.
        ;;
        ;; 1. move components (<= ttl 0) in pre-destroy from init/active to
        ;; destroy.
        ;;
        ;; 2. move root actors (<= ttl 0) (and their components)
        ;;    in pre-destroy from init/active to destroy.
        ;;
        ;; 3. Recursively move all actor children found in destroy from
        ;;    init/active into destroy, Set any actor/component ttl in any
        ;;    discovered instances to 0, since the root with ttl <= 0 overrides
        ;;    all pending ttls for anything that may be in the process of being
        ;;    destroyed.
        ;;
        ;; 4. If destroy is empty, go to 9.
        ;;
        ;; 5. run DESTROY-COMPONENT by-type in destroy.
        ;;
        ;; 6. release-components (and remove from actors) from destroy.
        ;;
        ;; 7. release-actors (which now should be empty) from destroy.
        ;;
        ;; 8. RESTART-DESTROYING-PHASE, goto 0.
        ;;
        ;; 9. decrement frame-time in ttl for actors and components.
        ;;
        ;; 10. exit flow.

        ;; 0
        (flow-state PENDING-PREDESTROY-TASKS :reset ()
                    (selector NIL)

                    (action NIL)

                    (transition
                     (lambda (core-state)
                       (if (pending-predestroy-tasks-p core-state)
                           PREPARE-PREDESTROY-COMPONENTS
                           EXIT/DESTROY-PHASE))))

        ;; 1
        (flow-state PREPARE-PREDESTROY-COMPONENTS :reset ()
                    (selector
                     (lambda (core-state)
                       (values :identity-policy
                               (component-predestroy-view core-state))))

                    (action
                     (lambda (core-state component)
                       (when (<= (ttl component) 0)
                         (component/init-or-active->destroy core-state
                                                            component))))

                    (transition
                     (lambda (core-state)
		       (declare (ignore core-state))
                       PREPARE-PREDESTROY-ACTORS)))

        ;; 2
        (flow-state PREPARE-PREDESTROY-ACTORS :reset ()
                    (selector NIL)
                    (action NIL)
                    (transition NIL))

        ;; 3
        (flow-state DESTROY-ACTOR-CHILDREN :reset ()
                    (selector NIL)
                    (action NIL)
                    (transition NIL))

        ;; 4
        (flow-state PENDING-DESTROY-TASKS :reset ()
                    (selector NIL)
                    (action NIL)
                    (transition NIL))

        ;; 5
        (flow-state PROTOCOL-DESTROY-COMPONENT :reset ()
                    (selector NIL)
                    (action NIL)
                    (transition NIL))

        ;; 6
        (flow-state RELEASE-COMPONENTS :reset ()
                    (selector NIL)
                    (action NIL)
                    (transition NIL))

        ;; 7
        (flow-state RELEASE-ACTORS :reset ()
                    (selector NIL)
                    (action NIL)
                    (transition NIL))

        ;; 8
        (flow-state RESTART-DESTROY-PHASE :reset ()
                    (selector NIL)
                    (action NIL)
                    (transition NIL))

        ;; 9
        (flow-state DECREMENT-DESTROY-TIMER :reset ()
                    (selector NIL)
                    (action NIL)
                    (transition NIL))

        ;; 10
        (flow-state EXIT/DESTROY-PHASE :reset ()
                    (selector NIL)
                    (action NIL)
                    (transition NIL)))


  (flow maintenance-phase
        (flow-state ENTRY/MAINTENANCE-PHASE :reset ()
                    (selector NIL)
                    (action NIL)
                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       SHADER-REFRESH)))

        (flow-state SHADER-REFRESH :reset ()
                    (selector
                     (lambda (core-state)
                       (values :identity-policy
                               core-state)))

                    (action
                     (lambda (core-state inst)
                       (declare (ignore inst))
                       (maybe-recompile-shaders core-state)
                       nil))

                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       EXIT/MAINTENANCE-PHASE)))

        (flow-state EXIT/MAINTENANCE-PHASE :reset ()
                    (selector NIL)
                    (action NIL)
                    (transition NIL)))


  (flow perform-one-frame
        (flow-state ENTRY/PERFORM-ONE-FRAME :reset ()
                    (selector NIL)
                    (action NIL)
                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       INITIALIZE-PHASE)))

        (flow-state INITIALIZE-PHASE :reset ()
                    (selector
                     (lambda (core-state)
                       (values :identity-policy
                               core-state)))

                    (action
                     (lambda (core-state inst)
                       (declare (ignore inst))
                       (execute-flow core-state
                                     :default
                                     'initialize-phase
                                     'ENTRY/INITIALIZE-PHASE
                                     :come-from-state-name
                                     :EF-REALIZE-PHASE)))

                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       ACTIVE-PHASE)))

        (flow-state ACTIVE-PHASE :reset ()
                    (selector
                     (lambda (core-state)
                       (values :identity-policy
                               core-state)))

                    (action
                     (lambda (core-state inst)
                       (declare (ignore inst))
                       (execute-flow core-state
                                     :default
                                     'active-phase
                                     'ENTRY/ACTIVE-PHASE
                                     :come-from-state-name
                                     :EF-ACTIVE-PHASE)))

                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       DESTROY-PHASE)))

        (flow-state DESTROY-PHASE :reset ()
                    (selector
                     (lambda (core-state)
                       (values :identity-policy
                               core-state)))

                    (action
                     (lambda (core-state inst)
                       (declare (ignore inst))
                       (execute-flow core-state
                                     :default
                                     'destroy-phase
                                     'ENTRY/DESTROY-PHASE
                                     :come-from-state-name
                                     :EF-DESTROY-PHASE)))

                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       MAINTENANCE-PHASE)))

        (flow-state MAINTENANCE-PHASE :reset ()
                    (selector
                     (lambda (core-state)
                       (values :identity-policy
                               core-state)))

                    (action
                     (lambda (core-state inst)
                       (declare (ignore inst))
                       (execute-flow core-state
                                     :default
                                     'maintenance-phase
                                     'ENTRY/MAINTENANCE-PHASE
                                     :come-from-state-name
                                     :EF-MAINTENANCE-PHASE)))

                    (transition
                     (lambda (core-state)
                       (declare (ignore core-state))
                       EXIT/DO-NEXT-FRAME)))

        (flow-state EXIT/DO-NEXT-FRAME :reset ()
                    (selector NIL)
                    (action NIL)
                    (transition NIL))

        (flow-state EXIT/GAME-OVER :reset ()
                    (selector NIL)
                    (action NIL)
                    (transition NIL))))
